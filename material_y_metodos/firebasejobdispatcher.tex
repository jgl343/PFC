\label{jobscheduler}

\subsection{WorkManager}
\subsubsection{WorkManager API}
Para realizar las llamadas a nuestro backend utilizaremos la 
API WorkManager, que nos facilitará la programación de tareas
 asíncronas incluso si la aplicación sale o se reinicia el dispositivo.

Es mejor que utilizar un proceso en segundo plano, ya que
 mantener aplicaciones en segundo plano consume mucha batería
 y el problema se acentúa cuando todos esos servicios en segundo
 plano están escuchando transmisiones frecuentes, por ejemplo
 para saber si hay conexión a la red.

Las principales características ofrecidas por esta API son:

\begin{itemize}
\item Permite agregar restricciones de trabajo como disponibilidad de red.
\item Permite programar tareas únicas o tareas asíncronas periódicas.
\item Monitorizar y gestionar las tareas programadas.
\item Podemos encadenar tareas distintas.
\item Asegura la ejecución de tareas, incluso si la aplicación o 
el dispositivo se reinicia.
\item Nos permite utilizar las funciones de ahorro de energía
 como el modo reposo.
\end{itemize}

\subsubsection{Uso en nuestra aplicación}

Encapsularemos nuestra función que comprueba si vamos a la deriva
 dentro de la clase OneTimeWorkRequest, que nos ejecutará la 
operación cada cinco minutos.

En el caso que la resolución de la función nos indique que estamos
 a la deriva, encadenaremos el objeto WorkContinuation para enlazar
 la función que muestra el aviso, durante cinco minutos de que vamos a llamar al 112.

Una vez terminado este tiempo, si no se ha detenido la ejecución mediante un botón que mostraremos en pantalla, encolaremos la última función, que será la encargada de llamar al 112.


\footnote{Fuente:Android WorkManager~\cite{ANDROIDWORKMANAGER}}